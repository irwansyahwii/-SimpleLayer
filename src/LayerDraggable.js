// Generated by CoffeeScript 1.9.2
(function() {
  var BaseClass, Defaults, EventBuffer, Events, Simulation, Utils, _,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  _ = require("./Underscore")._;

  Utils = require("./Utils");

  BaseClass = require("./BaseClass").BaseClass;

  Events = require("./Events").Events;

  Simulation = require("./Simulation").Simulation;

  Defaults = require("./Defaults").Defaults;

  EventBuffer = require("./EventBuffer").EventBuffer;

  Events.Move = "move";

  Events.DragStart = "dragstart";

  Events.DragWillMove = "dragwillmove";

  Events.DragMove = "dragmove";

  Events.DragDidMove = "dragmove";

  Events.Drag = "dragmove";

  Events.DragEnd = "dragend";

  Events.DragAnimationDidStart = "draganimationdidstart";

  Events.DragAnimationDidEnd = "draganimationdidend";

  Events.DirectionLockDidStart = "directionlockdidstart";

  "         \n┌──────┐                   │         \n│      │                             \n│      │  ───────────────▶ │ ◀────▶  \n│      │                             \n└──────┘                   │         \n                                     \n════════  ═════════════════ ═══════  \n                                     \n  Drag         Momentum      Bounce  \n                                         ";

  exports.LayerDraggable = (function(superClass) {
    extend(LayerDraggable, superClass);

    LayerDraggable.define("speedX", LayerDraggable.simpleProperty("speedX", 1));

    LayerDraggable.define("speedY", LayerDraggable.simpleProperty("speedY", 1));

    LayerDraggable.define("horizontal", LayerDraggable.simpleProperty("horizontal", true));

    LayerDraggable.define("vertical", LayerDraggable.simpleProperty("vertical", true));

    LayerDraggable.define("momentumVelocityMultiplier", LayerDraggable.simpleProperty("momentumVelocityMultiplier", 800));

    LayerDraggable.define("directionLock", LayerDraggable.simpleProperty("directionLock", true));

    LayerDraggable.define("directionLockThreshold", LayerDraggable.simpleProperty("directionLockThreshold", {
      x: 10,
      y: 10
    }));

    LayerDraggable.define("propagateEvents", LayerDraggable.simpleProperty("propagateEvents", true));

    LayerDraggable.define("constraints", {
      get: function() {
        return this._constraints;
      },
      set: function(value) {
        if (value && _.isObject(value)) {
          this._constraints = _.defaults(value, {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          });
        } else {
          this._constraints = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
        if (this._constraints) {
          return this._updateSimulationConstraints(this._constraints);
        }
      }
    });

    LayerDraggable.define("isDragging", {
      get: function() {
        return this._isDragging || false;
      }
    });

    LayerDraggable.define("isAnimating", {
      get: function() {
        return this._isAnimating || false;
      }
    });

    LayerDraggable.define("isMoving", {
      get: function() {
        return this._isMoving || false;
      }
    });

    LayerDraggable.define("layerStartPoint", {
      get: function() {
        return this._layerStartPoint || this.layer.point;
      }
    });

    LayerDraggable.define("cursorStartPoint", {
      get: function() {
        return this._cursorStartPoint || {
          x: 0,
          y: 0
        };
      }
    });

    LayerDraggable.define("layerCursorOffset", {
      get: function() {
        return this._layerCursorOffset || {
          x: 0,
          y: 0
        };
      }
    });

    LayerDraggable.define("offset", {
      get: function() {
        var offset;
        if (!this._correctedLayerStartPoint) {
          return {
            x: 0,
            y: 0
          };
        }
        return offset = {
          x: this.layer.x - this._correctedLayerStartPoint.x,
          y: this.layer.y - this._correctedLayerStartPoint.y
        };
      }
    });

    function LayerDraggable(layer) {
      var options;
      this.layer = layer;
      this._stopSimulation = bind(this._stopSimulation, this);
      this._onSimulationStop = bind(this._onSimulationStop, this);
      this._onSimulationStep = bind(this._onSimulationStep, this);
      this._touchEnd = bind(this._touchEnd, this);
      this._touchMove = bind(this._touchMove, this);
      this._touchStart = bind(this._touchStart, this);
      this.touchStart = bind(this.touchStart, this);
      options = Defaults.getDefaults("LayerDraggable", {});
      LayerDraggable.__super__.constructor.call(this, options);
      _.extend(this, options);
      this.enabled = true;
      this._eventBuffer = new EventBuffer;
      this._constraints = null;
      this.attach();
    }

    LayerDraggable.prototype.attach = function() {
      return this.layer.on(Events.TouchStart, this._touchStart);
    };

    LayerDraggable.prototype.remove = function() {
      return this.layer.off(Events.TouchStart, this._touchStart);
    };

    LayerDraggable.prototype.updatePosition = function(point) {
      return point;
    };

    LayerDraggable.prototype.touchStart = function(event) {
      return this._touchStart(event);
    };

    LayerDraggable.prototype._touchStart = function(event) {
      var touchEvent;
      this._isMoving = this.isAnimating;
      this.layer.animateStop();
      this._stopSimulation();
      this._resetdirectionLock();
      event.preventDefault();
      if (!this.propagateEvents) {
        event.stopPropagation();
      }
      touchEvent = Events.touchEvent(event);
      this._eventBuffer.push({
        x: touchEvent.clientX,
        y: touchEvent.clientY,
        t: Date.now()
      });
      this._layerStartPoint = this.layer.point;
      this._correctedLayerStartPoint = this.layer.point;
      if (this.constraints && this.bounce) {
        this._correctedLayerStartPoint = this._constrainPosition(this._correctedLayerStartPoint, this.constraints, 1 / this.overdragScale);
      }
      this._cursorStartPoint = {
        x: touchEvent.clientX,
        y: touchEvent.clientY
      };
      this._layerCursorOffset = {
        x: touchEvent.clientX - this._correctedLayerStartPoint.x,
        y: touchEvent.clientY - this._correctedLayerStartPoint.y
      };
      document.addEventListener(Events.TouchMove, this._touchMove);
      document.addEventListener(Events.TouchEnd, this._touchEnd);
      return this.emit(Events.DragStart, event);
    };

    LayerDraggable.prototype._touchMove = function(event) {
      var offset, point, touchEvent;
      if (!this.enabled) {
        return;
      }
      event.preventDefault();
      if (!this.propagateEvents) {
        event.stopPropagation();
      }
      touchEvent = Events.touchEvent(event);
      this._eventBuffer.push({
        x: touchEvent.clientX,
        y: touchEvent.clientY,
        t: Date.now()
      });
      offset = {
        x: touchEvent.clientX - this._correctedLayerStartPoint.x - this._layerCursorOffset.x,
        y: touchEvent.clientY - this._correctedLayerStartPoint.y - this._layerCursorOffset.y
      };
      offset.x = offset.x * this.speedX * (1 / this.layer.canvasScaleX()) * this.layer.scaleX * this.layer.scale;
      offset.y = offset.y * this.speedY * (1 / this.layer.canvasScaleY()) * this.layer.scaleY * this.layer.scale;
      point = this.layer.point;
      if (this.horizontal) {
        point.x = this._correctedLayerStartPoint.x + offset.x;
      }
      if (this.vertical) {
        point.y = this._correctedLayerStartPoint.y + offset.y;
      }
      if (this._constraints) {
        point = this._constrainPosition(point, this._constraints, this.overdragScale);
      }
      if (this.directionLock) {
        if (!this._directionLockEnabledX && !this._directionLockEnabledY) {
          this._updatedirectionLock(offset);
          return;
        } else {
          if (this._directionLockEnabledX) {
            point.x = this._layerStartPoint.x;
          }
          if (this._directionLockEnabledY) {
            point.y = this._layerStartPoint.y;
          }
        }
      }
      if (this.pixelAlign) {
        point.x = parseInt(point.x);
        point.y = parseInt(point.y);
      }
      if (point.x !== this._layerStartPoint.x || point.y !== this._layerStartPoint.y) {
        this._isDragging = true;
        this._isMoving = true;
      }
      if (this.isDragging) {
        this.emit(Events.DragWillMove, event);
      }
      this.layer.point = this.updatePosition(point);
      if (this.isDragging) {
        this.emit(Events.Move, this.layer.point);
        return this.emit(Events.DragDidMove, event);
      }
    };

    LayerDraggable.prototype._touchEnd = function(event) {
      if (!this.propagateEvents) {
        event.stopPropagation();
      }
      document.removeEventListener(Events.TouchMove, this._touchMove);
      document.removeEventListener(Events.TouchEnd, this._touchEnd);
      this._startSimulation();
      this.emit(Events.DragEnd, event);
      return this._isDragging = false;
    };

    LayerDraggable.define("constraintsOffset", {
      get: function() {
        var constrainedPoint, maxX, maxY, minX, minY, offset, point, ref;
        if (!this.constraints) {
          return {
            x: 0,
            y: 0
          };
        }
        ref = this._calculateConstraints(this.constraints), minX = ref.minX, maxX = ref.maxX, minY = ref.minY, maxY = ref.maxY;
        point = this.layer.point;
        constrainedPoint = {
          x: Utils.clamp(point.x, minX, maxX),
          y: Utils.clamp(point.y, minY, maxY)
        };
        offset = {
          x: point.x - constrainedPoint.x,
          y: point.y - constrainedPoint.y
        };
        return offset;
      }
    });

    LayerDraggable.define("isBeyondConstraints", {
      get: function() {
        var constraintsOffset;
        constraintsOffset = this.constraintsOffset;
        if (constraintsOffset.x !== 0) {
          return true;
        }
        if (constraintsOffset.y !== 0) {
          return true;
        }
        return false;
      }
    });

    LayerDraggable.prototype._clampAndScale = function(value, min, max, scale) {
      if (value < min) {
        value = min + (value - min) * scale;
      }
      if (value > max) {
        value = max + (value - max) * scale;
      }
      return value;
    };

    LayerDraggable.prototype._calculateConstraints = function(bounds) {
      var constraints;
      if (!bounds) {
        return constraints = {
          minX: Infinity,
          maxX: Infinity,
          minY: Infinity,
          maxY: Infinity
        };
      }
      constraints = {
        minX: Utils.frameGetMinX(bounds),
        maxX: Utils.frameGetMaxX(bounds),
        minY: Utils.frameGetMinY(bounds),
        maxY: Utils.frameGetMaxY(bounds)
      };
      constraints.maxX -= this.layer.width;
      constraints.maxY -= this.layer.height;
      return constraints;
    };

    LayerDraggable.prototype._constrainPosition = function(proposedPoint, bounds, scale) {
      var maxX, maxY, minX, minY, point, ref;
      ref = this._calculateConstraints(this._constraints), minX = ref.minX, maxX = ref.maxX, minY = ref.minY, maxY = ref.maxY;
      if (this.overdrag) {
        point = {
          x: this._clampAndScale(proposedPoint.x, minX, maxX, scale),
          y: this._clampAndScale(proposedPoint.y, minY, maxY, scale)
        };
      } else {
        point = {
          x: Utils.clamp(proposedPoint.x, minX, maxX),
          y: Utils.clamp(proposedPoint.y, minY, maxY)
        };
      }
      if (this.speedX === 0 || this.horizontal === false) {
        point.x = proposedPoint.x;
      }
      if (this.speedY === 0 || this.vertical === false) {
        point.y = proposedPoint.y;
      }
      return point;
    };

    LayerDraggable.define("velocity", {
      get: function() {
        if (this.isAnimating) {
          return this._calculateSimulationVelocity();
        }
        return this._eventBuffer.velocity;
        return {
          x: 0,
          y: 0
        };
      }
    });

    LayerDraggable.define("angle", {
      get: function() {
        return this._eventBuffer.angle;
      }
    });

    LayerDraggable.define("direction", {
      get: function() {
        var velocity;
        velocity = this.velocity;
        if (Math.abs(velocity.x) > Math.abs(velocity.y)) {
          if (velocity.x > 0) {
            return "right";
          }
          return "left";
        } else {
          if (velocity.y > 0) {
            return "down";
          }
          return "up";
        }
      }
    });

    LayerDraggable.prototype.calculateVelocity = function() {
      return this.velocity;
    };

    LayerDraggable.prototype._calculateSimulationVelocity = function() {
      var velocity, xFinished, yFinished;
      xFinished = this._simulation.x.finished();
      yFinished = this._simulation.y.finished();
      velocity = {
        x: 0,
        y: 0
      };
      if (!xFinished) {
        velocity.x = this._simulation.x.simulator.state.v / this.momentumVelocityMultiplier;
      }
      if (!yFinished) {
        velocity.y = this._simulation.y.simulator.state.v / this.momentumVelocityMultiplier;
      }
      return velocity;
    };

    LayerDraggable.prototype.emit = function(eventName, event) {
      this.layer.emit(eventName, event, this);
      return LayerDraggable.__super__.emit.call(this, eventName, event, this);
    };

    LayerDraggable.prototype._updatedirectionLock = function(correctedDelta) {
      this._directionLockEnabledX = Math.abs(correctedDelta.y) > this.directionLockThreshold.y;
      this._directionLockEnabledY = Math.abs(correctedDelta.x) > this.directionLockThreshold.x;
      if (this._directionLockEnabledX || this._directionLockEnabledY) {
        return this.emit(Events.DirectionLockDidStart, {
          x: this._directionLockEnabledX,
          y: this._directionLockEnabledY
        });
      }
    };

    LayerDraggable.prototype._resetdirectionLock = function() {
      this._directionLockEnabledX = false;
      return this._directionLockEnabledY = false;
    };

    LayerDraggable.prototype._setupSimulation = function() {
      if (this._simulation) {
        return;
      }
      this._simulation = {
        x: this._setupSimulationForAxis("x"),
        y: this._setupSimulationForAxis("y")
      };
      return this._updateSimulationConstraints(this.constraints);
    };

    LayerDraggable.prototype._setupSimulationForAxis = function(axis) {
      var properties, simulation;
      properties = {};
      properties[axis] = true;
      simulation = new Simulation({
        layer: this.layer,
        properties: properties,
        model: "inertial-scroll",
        modelOptions: {
          momentum: this.momentumOptions,
          bounce: this.bounceOptions
        }
      });
      simulation.on(Events.SimulationStep, (function(_this) {
        return function(state) {
          return _this._onSimulationStep(axis, state);
        };
      })(this));
      simulation.on(Events.SimulationStop, (function(_this) {
        return function(state) {
          return _this._onSimulationStop(axis, state);
        };
      })(this));
      return simulation;
    };

    LayerDraggable.prototype._updateSimulationConstraints = function(constraints) {
      var maxX, maxY, minX, minY, ref;
      if (!this._simulation) {
        return;
      }
      if (constraints) {
        ref = this._calculateConstraints(this._constraints), minX = ref.minX, maxX = ref.maxX, minY = ref.minY, maxY = ref.maxY;
        this._simulation.x.simulator.options = {
          min: minX,
          max: maxX
        };
        return this._simulation.y.simulator.options = {
          min: minY,
          max: maxY
        };
      } else {
        this._simulation.x.simulator.options = {
          min: -Infinity,
          max: +Infinity
        };
        return this._simulation.y.simulator.options = {
          min: -Infinity,
          max: +Infinity
        };
      }
    };

    LayerDraggable.prototype._onSimulationStep = function(axis, state) {
      var delta, maxX, maxY, minX, minY, ref, updatePoint;
      if (axis === "x" && this.horizontal === false) {
        return;
      }
      if (axis === "y" && this.vertical === false) {
        return;
      }
      if (this.constraints) {
        if (this.bounce) {
          delta = state.x - this.layer[axis];
        } else {
          ref = this._calculateConstraints(this._constraints), minX = ref.minX, maxX = ref.maxX, minY = ref.minY, maxY = ref.maxY;
          if (axis === "x") {
            delta = Utils.clamp(state.x, minX, maxX) - this.layer[axis];
          }
          if (axis === "y") {
            delta = Utils.clamp(state.x, minY, maxY) - this.layer[axis];
          }
        }
      } else {
        delta = state.x - this.layer[axis];
      }
      updatePoint = this.layer.point;
      if (axis === "x") {
        updatePoint[axis] = updatePoint[axis] + (delta * this.speedX);
      }
      if (axis === "y") {
        updatePoint[axis] = updatePoint[axis] + (delta * this.speedY);
      }
      this.updatePosition(updatePoint);
      this.layer[axis] = this.updatePosition(updatePoint)[axis];
      return this.emit(Events.Move, this.layer.point);
    };

    LayerDraggable.prototype._onSimulationStop = function(axis, state) {
      if (!this._simulation) {
        return;
      }
      if (this.pixelAlign) {
        this.layer[axis] = parseInt(this.layer[axis]);
      }
      if (this._simulation.x.finished() && this._simulation.y.finished()) {
        return this._stopSimulation();
      }
    };

    LayerDraggable.prototype._startSimulation = function() {
      var maxX, maxY, minX, minY, ref, startSimulationX, startSimulationY, velocity, velocityX, velocityY;
      if (!(this.momentum || this.bounce)) {
        return;
      }
      if (this.isBeyondConstraints === false && this.momentum === false) {
        return;
      }
      if (this.isBeyondConstraints === false && this.isDragging === false) {
        return;
      }
      ref = this._calculateConstraints(this._constraints), minX = ref.minX, maxX = ref.maxX, minY = ref.minY, maxY = ref.maxY;
      startSimulationX = this.overdrag === true || (this.layer.x > minX && this.layer.x < maxX);
      startSimulationY = this.overdrag === true || (this.layer.y > minY && this.layer.y < maxY);
      if ((startSimulationX === startSimulationY && startSimulationY === false)) {
        return;
      }
      velocity = this.velocity;
      velocityX = velocity.x * this.momentumVelocityMultiplier * this.speedX * (1 / this.layer.canvasScaleX()) * this.layer.scaleX * this.layer.scale;
      velocityY = velocity.y * this.momentumVelocityMultiplier * this.speedY * (1 / this.layer.canvasScaleY()) * this.layer.scaleY * this.layer.scale;
      this._setupSimulation();
      this._isAnimating = true;
      this._isMoving = true;
      this._simulation.x.simulator.setState({
        x: this.layer.x,
        v: velocityX
      });
      if (startSimulationX) {
        this._simulation.x.start();
      }
      this._simulation.y.simulator.setState({
        x: this.layer.y,
        v: velocityY
      });
      if (startSimulationY) {
        this._simulation.y.start();
      }
      return this.emit(Events.DragAnimationDidStart);
    };

    LayerDraggable.prototype._stopSimulation = function() {
      var ref, ref1;
      this._isAnimating = false;
      if (!this._simulation) {
        return;
      }
      if ((ref = this._simulation) != null) {
        ref.x.stop();
      }
      if ((ref1 = this._simulation) != null) {
        ref1.y.stop();
      }
      this._simulation = null;
      this.emit(Events.Move, this.layer.point);
      return this.emit(Events.DragAnimationDidEnd);
    };

    LayerDraggable.prototype.animateStop = function() {
      return this._stopSimulation();
    };

    return LayerDraggable;

  })(BaseClass);

}).call(this);
