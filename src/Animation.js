// Generated by CoffeeScript 1.9.2
(function() {
  var AnimatorClassBezierPresets, AnimatorClasses, BezierCurveAnimator, Config, Defaults, EventEmitter, LinearAnimator, SpringDHOAnimator, SpringRK4Animator, Utils, _, evaluateRelativeProperty, isRelativeProperty, numberRE, relativePropertyRE,
    slice = [].slice,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require("./Underscore")._;

  Utils = require("./Utils");

  Config = require("./Config").Config;

  Defaults = require("./Defaults").Defaults;

  EventEmitter = require("./EventEmitter").EventEmitter;

  LinearAnimator = require("./Animators/LinearAnimator").LinearAnimator;

  BezierCurveAnimator = require("./Animators/BezierCurveAnimator").BezierCurveAnimator;

  SpringRK4Animator = require("./Animators/SpringRK4Animator").SpringRK4Animator;

  SpringDHOAnimator = require("./Animators/SpringDHOAnimator").SpringDHOAnimator;

  AnimatorClasses = {
    "linear": LinearAnimator,
    "bezier-curve": BezierCurveAnimator,
    "spring-rk4": SpringRK4Animator,
    "spring-dho": SpringDHOAnimator
  };

  AnimatorClasses["spring"] = AnimatorClasses["spring-rk4"];

  AnimatorClasses["cubic-bezier"] = AnimatorClasses["bezier-curve"];

  AnimatorClassBezierPresets = ["ease", "ease-in", "ease-out", "ease-in-out"];

  numberRE = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/;

  relativePropertyRE = new RegExp('^(?:([+-])=|)(' + numberRE.source + ')([a-z%]*)$', 'i');

  isRelativeProperty = function(v) {
    return _.isString(v) && relativePropertyRE.test(v);
  };

  evaluateRelativeProperty = function(target, k, v) {
    var match, number, ref, rest, sign, unit;
    ref = relativePropertyRE.exec(v), match = ref[0], sign = ref[1], number = ref[2], unit = ref[3], rest = 5 <= ref.length ? slice.call(ref, 4) : [];
    if (sign) {
      return target[k] + (sign + 1) * number;
    }
    return +number;
  };

  exports.Animation = (function(superClass) {
    extend(Animation, superClass);

    function Animation(options) {
      if (options == null) {
        options = {};
      }
      this._updateValue = bind(this._updateValue, this);
      this._update = bind(this._update, this);
      this._start = bind(this._start, this);
      this.start = bind(this.start, this);
      options = Defaults.getDefaults("Animation", options);
      Animation.__super__.constructor.call(this, options);
      this.options = _.clone(_.defaults(options, {
        layer: null,
        properties: {},
        curve: "linear",
        curveOptions: {},
        time: 1,
        repeat: 0,
        delay: 0,
        debug: false
      }));
      if (options.origin) {
        console.warn("Animation.origin: please use layer.originX and layer.originY");
      }
      this.options.properties = Animation.filterAnimatableProperties(this.options.properties);
      this._parseAnimatorOptions();
      this._originalState = this._currentState();
      this._repeatCounter = this.options.repeat;
    }

    Animation.prototype.start = function() {
      var AnimatorClass, animation, k, property, ref, ref1, ref2, v;
      if (this.options.layer === null) {
        console.error("Animation: missing layer");
      }
      AnimatorClass = this._animatorClass();
      if (this.options.debug) {
        console.log("Animation.start " + AnimatorClass.name, this.options.curveOptions);
      }
      this._animator = new AnimatorClass(this.options.curveOptions);
      this._target = this.options.layer;
      this._stateA = this._currentState();
      this._stateB = {};
      ref = this.options.properties;
      for (k in ref) {
        v = ref[k];
        if (_.isFunction(v)) {
          v = v();
        } else if (isRelativeProperty(v)) {
          v = evaluateRelativeProperty(this._target, k, v);
        }
        if (this._stateA[k] !== v) {
          this._stateB[k] = v;
        }
      }
      if (_.keys(this._stateA).length === 0) {
        console.warn("Animation: nothing to animate, no animatable properties");
        return false;
      }
      if (_.isEqual(this._stateA, this._stateB)) {
        console.warn("Animation: nothing to animate, all properties are equal to what it is now");
        return false;
      }
      ref1 = this._target.animatingProperties();
      for (property in ref1) {
        animation = ref1[property];
        if (this._stateA.hasOwnProperty(property)) {
          animation.stop();
        }
      }
      if (this.options.debug) {
        console.log("Animation.start");
        ref2 = this._stateB;
        for (k in ref2) {
          v = ref2[k];
          console.log("\t" + k + ": " + this._stateA[k] + " -> " + this._stateB[k]);
        }
      }
      if (this._repeatCounter > 0) {
        this.once("end", (function(_this) {
          return function() {
            var ref3;
            ref3 = _this._stateA;
            for (k in ref3) {
              v = ref3[k];
              _this._target[k] = v;
            }
            _this._repeatCounter--;
            return _this.start();
          };
        })(this));
      }
      if (this.options.delay) {
        Utils.delay(this.options.delay, this._start);
      } else {
        this._start();
      }
      return true;
    };

    Animation.prototype.stop = function(emit) {
      if (emit == null) {
        emit = true;
      }
      this.options.layer._context._animationList = _.without(this.options.layer._context._animationList, this);
      if (emit) {
        this.emit("stop");
      }
      return Framer.Loop.off("update", this._update);
    };

    Animation.prototype.reverse = function() {
      var animation, options;
      options = _.clone(this.options);
      options.properties = this._originalState;
      animation = new Animation(options);
      return animation;
    };

    Animation.prototype.copy = function() {
      return new Animation(_.clone(this.options));
    };

    Animation.prototype.revert = function() {
      return this.reverse();
    };

    Animation.prototype.inverse = function() {
      return this.reverse();
    };

    Animation.prototype.invert = function() {
      return this.reverse();
    };

    Animation.prototype.emit = function(event) {
      Animation.__super__.emit.apply(this, arguments);
      return this.options.layer.emit(event, this);
    };

    Animation.prototype.animatingProperties = function() {
      return _.keys(this._stateA);
    };

    Animation.prototype._start = function() {
      this.options.layer._context._animationList.push(this);
      this.emit("start");
      return Framer.Loop.on("update", this._update);
    };

    Animation.prototype._update = function(delta) {
      var emit;
      if (this._animator.finished()) {
        this._updateValue(1);
        this.stop(emit = false);
        this.emit("end");
        return this.emit("stop");
      } else {
        return this._updateValue(this._animator.next(delta));
      }
    };

    Animation.prototype._updateValue = function(value) {
      var k, ref, v;
      ref = this._stateB;
      for (k in ref) {
        v = ref[k];
        this._target[k] = Utils.mapRange(value, 0, 1, this._stateA[k], this._stateB[k]);
      }
    };

    Animation.prototype._currentState = function() {
      return _.pick(this.options.layer, _.keys(this.options.properties));
    };

    Animation.prototype._animatorClass = function() {
      var animatorClassName, parsedCurve;
      parsedCurve = Utils.parseFunction(this.options.curve);
      animatorClassName = parsedCurve.name.toLowerCase();
      if (AnimatorClasses.hasOwnProperty(animatorClassName)) {
        return AnimatorClasses[animatorClassName];
      }
      if (indexOf.call(AnimatorClassBezierPresets, animatorClassName) >= 0) {
        return BezierCurveAnimator;
      }
      return LinearAnimator;
    };

    Animation.prototype._parseAnimatorOptions = function() {
      var animatorClass, animatorClassName, base, base1, i, j, k, l, len, len1, parsedCurve, ref, ref1, results, value;
      animatorClass = this._animatorClass();
      parsedCurve = Utils.parseFunction(this.options.curve);
      animatorClassName = parsedCurve.name.toLowerCase();
      if (animatorClass === LinearAnimator || animatorClass === BezierCurveAnimator) {
        if (_.isString(this.options.curveOptions) || _.isArray(this.options.curveOptions)) {
          this.options.curveOptions = {
            values: this.options.curveOptions
          };
        }
        if ((base = this.options.curveOptions).time == null) {
          base.time = this.options.time;
        }
      }
      if ((animatorClass === BezierCurveAnimator) && indexOf.call(AnimatorClassBezierPresets, animatorClassName) >= 0) {
        this.options.curveOptions.values = animatorClassName;
        if ((base1 = this.options.curveOptions).time == null) {
          base1.time = this.options.time;
        }
      }
      if (parsedCurve.args.length) {
        if (animatorClass === BezierCurveAnimator) {
          this.options.curveOptions.values = parsedCurve.args.map(function(v) {
            return parseFloat(v) || 0;
          });
        }
        if (animatorClass === SpringRK4Animator) {
          ref = ["tension", "friction", "velocity", "tolerance"];
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            k = ref[i];
            value = parseFloat(parsedCurve.args[i]);
            if (value) {
              this.options.curveOptions[k] = value;
            }
          }
        }
        if (animatorClass === SpringDHOAnimator) {
          ref1 = ["stiffness", "damping", "mass", "tolerance"];
          results = [];
          for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
            k = ref1[i];
            value = parseFloat(parsedCurve.args[i]);
            if (value) {
              results.push(this.options.curveOptions[k] = value);
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      }
    };

    Animation.filterAnimatableProperties = function(properties) {
      var animatableProperties, k, v;
      animatableProperties = {};
      for (k in properties) {
        v = properties[k];
        if (_.isNumber(v) || _.isFunction(v) || isRelativeProperty(v)) {
          animatableProperties[k] = v;
        }
      }
      return animatableProperties;
    };

    return Animation;

  })(EventEmitter);

}).call(this);
