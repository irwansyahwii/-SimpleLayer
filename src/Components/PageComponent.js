// Generated by CoffeeScript 1.9.2
(function() {
  var Events, ScrollComponent,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Events = require("../Events").Events;

  ScrollComponent = require("./ScrollComponent").ScrollComponent;

  "PageComponent\n\noriginX <number>\noriginY <number>\n\nvelocityThreshold <number>\nanimationOptions <animationOptions={}>\ncurrentPage <Layer>\nclosestPage(<originX:n, originY:n>) <Layer>\n\nnextPage(direction=\"\", currentPage)\nsnapToNextPage(direction=\"\", animate, animationOptions={})\n";

  exports.PageComponent = (function(superClass) {
    extend(PageComponent, superClass);

    PageComponent.define("originX", PageComponent.simpleProperty("originX", .5));

    PageComponent.define("originY", PageComponent.simpleProperty("originY", .5));

    PageComponent.define("velocityThreshold", PageComponent.simpleProperty("velocityThreshold", 0.1));

    PageComponent.define("animationOptions", PageComponent.simpleProperty("animationOptions", {
      curve: "spring(500,50,0)"
    }));

    function PageComponent() {
      this._resetHistory = bind(this._resetHistory, this);
      this._scrollEnd = bind(this._scrollEnd, this);
      this._onAminationEnd = bind(this._onAminationEnd, this);
      this._onAminationStep = bind(this._onAminationStep, this);
      this._onAminationStart = bind(this._onAminationStart, this);
      this._scrollMove = bind(this._scrollMove, this);
      this._scrollStart = bind(this._scrollStart, this);
      PageComponent.__super__.constructor.apply(this, arguments);
      this.content.draggable.momentum = false;
      this.content.draggable.bounce = false;
      this.on(Events.ScrollStart, this._scrollStart);
      this.on(Events.ScrollEnd, this._scrollEnd);
      this.content.on("change:frame", _.debounce(this._scrollMove, 16));
      this.content.on("change:subLayers", this._resetHistory);
      this._resetHistory();
    }

    PageComponent.define("closestPage", {
      get: function() {
        return this.closestContentLayerForScrollPoint(this._originScrollPoint(), this.originX, this.originY);
      }
    });

    PageComponent.define("currentPage", {
      get: function() {
        return _.last(this._previousPages);
      }
    });

    PageComponent.define("previousPage", {
      get: function() {
        return this._previousPages[this._previousPages.length - 2];
      }
    });

    PageComponent.prototype.nextPage = function(direction, currentPage, withoutCurrentPage) {
      var layers, point;
      if (direction == null) {
        direction = "right";
      }
      if (currentPage == null) {
        currentPage = null;
      }
      if (withoutCurrentPage == null) {
        withoutCurrentPage = true;
      }
      if (currentPage == null) {
        currentPage = this.currentPage;
      }
      point = {
        x: 0,
        y: 0
      };
      if (currentPage) {
        point = Utils.framePointForOrigin(currentPage, this.originX, this.originY);
      }
      if (!withoutCurrentPage) {
        point = {
          x: this.scrollX + (this.originX * this.width),
          y: this.scrollY + (this.originY * this.height)
        };
      }
      if (direction === "up" || direction === "top" || direction === "north") {
        layers = this.content.subLayersAbove(point, this.originX, this.originY);
      }
      if (direction === "down" || direction === "bottom" || direction === "south") {
        layers = this.content.subLayersBelow(point, this.originX, this.originY);
      }
      if (direction === "left" || direction === "west") {
        layers = this.content.subLayersLeft(point, this.originX, this.originY);
      }
      if (direction === "right" || direction === "east") {
        layers = this.content.subLayersRight(point, this.originX, this.originY);
      }
      if (withoutCurrentPage) {
        layers = _.without(layers, currentPage);
      }
      layers = Utils.frameSortByAbsoluteDistance(point, layers, this.originX, this.originY);
      return _.first(layers);
    };

    PageComponent.prototype.snapToPage = function(page, animate, animationOptions) {
      if (animate == null) {
        animate = true;
      }
      if (animationOptions == null) {
        animationOptions = null;
      }
      this.scrollToLayer(page, this.originX, this.originY, animate, animationOptions);
      if (this.currentPage !== page) {
        this._previousPages.push(page);
        this.emit("change:previousPage", this.previousPage);
        return this.emit("change:currentPage", this.currentPage);
      }
    };

    PageComponent.prototype.snapToNextPage = function(direction, animate, animationOptions) {
      var nextPage;
      if (direction == null) {
        direction = "right";
      }
      if (animate == null) {
        animate = true;
      }
      if (animationOptions == null) {
        animationOptions = null;
      }
      if (animationOptions == null) {
        animationOptions = this.animationOptions;
      }
      nextPage = this.nextPage(direction);
      if (nextPage == null) {
        nextPage = this.closestPage;
      }
      return this.snapToPage(nextPage, animate, animationOptions);
    };

    PageComponent.prototype.snapToPreviousPage = function() {
      if (!this.previousPage) {
        return;
      }
      this.snapToPage(this.previousPage);
      return this._previousPages = this._previousPages.slice(0, +(this._previousPages.length - 3) + 1 || 9e9);
    };

    PageComponent.prototype.addPage = function(page, direction) {
      var directions, point, ref;
      if (direction == null) {
        direction = "right";
      }
      directions = ["down", "bottom", "south"] + ["right", "east"];
      if (ref = !direction, indexOf.call(directions, ref) >= 0) {
        direction = "right";
        throw new Error(direction + " should be in " + directions);
      }
      point = page.point;
      if (this.content.subLayers.length) {
        if (direction === "right" || direction === "east") {
          point.x = Utils.frameGetMaxX(this.content.contentFrame());
        }
        if (direction === "down" || direction === "bottom" || direction === "south") {
          point.y = Utils.frameGetMaxY(this.content.contentFrame());
        }
      }
      page.point = point;
      if (page.superLayer !== this.content) {
        return page.superLayer = this.content;
      } else {
        return this.updateContent();
      }
    };

    PageComponent.prototype.setContentLayer = function(contentLayer) {
      if (this.content) {
        this._onAminateStop();
        this.content.off(Events.AnimationStart, this._onAminationStart);
        this.content.off(Events.AnimationStop, this._onAminationEnd);
      }
      PageComponent.__super__.setContentLayer.call(this, contentLayer);
      this.content.on(Events.AnimationStart, this._onAminationStart);
      return this.content.on(Events.AnimationStop, this._onAminationEnd);
    };

    PageComponent.prototype.horizontalPageIndex = function(page) {
      return (_.sortBy(this.content.subLayers, function(l) {
        return l.x;
      })).indexOf(page);
    };

    PageComponent.prototype.verticalPageIndex = function(page) {
      return (_.sortBy(this.content.subLayers, function(l) {
        return l.y;
      })).indexOf(page);
    };

    PageComponent.prototype._scrollStart = function() {
      return this._currentPage = this.currentPage;
    };

    PageComponent.prototype._scrollMove = function() {
      var currentPage;
      currentPage = this.currentPage;
      if (currentPage !== _.last(this._previousPages) && currentPage !== (void 0)) {
        this._previousPages.push(currentPage);
        return this.emit("change:currentPage", {
          old: this.previousPage,
          "new": currentPage
        });
      }
    };

    PageComponent.prototype._onAminationStart = function() {
      this._isMoving = true;
      this._isAnimating = true;
      return this.content.on("change:frame", this._onAminationStep);
    };

    PageComponent.prototype._onAminationStep = function() {
      return this.emit(Events.Move, this.content.point);
    };

    PageComponent.prototype._onAminationEnd = function() {
      this._isMoving = false;
      this._isAnimating = false;
      return this.content.off("change:frame", this._onAminationStep);
    };

    PageComponent.prototype._scrollEnd = function() {
      var end, nextPage, start, velocity, xDisabled, xLock, yDisabled, yLock;
      velocity = this.content.draggable.velocity;
      xDisabled = !this.scrollHorizontal && (this.direction === "right" || this.direction === "left");
      yDisabled = !this.scrollVertical && (this.direction === "down" || this.direction === "up");
      xLock = this.content.draggable._directionLockEnabledX && (this.direction === "right" || this.direction === "left");
      yLock = this.content.draggable._directionLockEnabledY && (this.direction === "down" || this.direction === "up");
      if (Math.max(Math.abs(velocity.x), Math.abs(velocity.y)) < this.velocityThreshold || xLock || yLock || xDisabled || yDisabled) {
        start = this.content.draggable._layerStartPoint;
        end = this.content.draggable.layer.point;
        if (start.x !== end.x || start.y !== end.y) {
          this.snapToPage(this.closestPage, true, this.animationOptions);
        }
        return;
      }
      nextPage = this.nextPage(this.direction, this._currentPage, false);
      if (nextPage == null) {
        nextPage = this.closestPage;
      }
      return this.snapToPage(nextPage, true, this.animationOptions);
    };

    PageComponent.prototype._originScrollPoint = function() {
      var scrollPoint;
      scrollPoint = this.scrollPoint;
      scrollPoint.x += this.width * this.originX;
      scrollPoint.y += this.height * this.originY;
      return scrollPoint;
    };

    PageComponent.prototype._resetHistory = function() {
      this._currentPage = this.closestPage;
      return this._previousPages = [this._currentPage];
    };

    return PageComponent;

  })(ScrollComponent);

}).call(this);
